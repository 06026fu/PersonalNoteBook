递归/分治
    原问题可以分成几个规模更小、性质相同的子问题
    或原问题时子问题的合并
    求解时仅需关注如何把原问题划分成符合条件的子问题
    分解->触底解决->合并
    
    递归树过高不可取

    明白一个函数的作用并相信可行，就不要探究细节(你脑子能压几个栈)

    时间复杂度计算
    主定理(Master Theorem)
        a=分解成几个子问题（a≥1）
        b=问题规模减少的倍数（b>1）
        f(n)=合并消耗时间
        T(n) = aT(n/b) + f(n)  （T(n)表示解决规模为n的问题所需的时间）

        主定理包含三种情况，用于判断递归算法的时间复杂度：
        1. 如果存在ε>0，使得f(n) = O(n^(log_b a - ε))，
            则 T(n) = Θ(n^(log_b a))
           （当f(n)的增长速度比n^(log_b a)慢时）

        2. 如果存在k≥0，使得f(n) = Θ(n^(log_b a) * (log n)^k)，
            则 T(n) = Θ(n^(log_b a) * (log n)^(k+1))
           （当f(n)的增长速度与n^(log_b a)相当时，乘以一个对数因子）

        3. 如果存在ε>0，使得f(n) = Ω(n^(log_b a + ε))，并且存在常数c<1，使得对于足够大的n，有a*f(n/b) ≤ c*f(n)，
            则 T(n) = Θ(f(n))
           （当f(n)的增长速度比n^(log_b a)快时）

        简言之，主定理通过比较f(n)与n^(log_b a)的增长速度来确定递归算法的时间复杂度。




