# 常用排序算法介绍

## 1. 冒泡排序（Bubble Sort）
- **算法思路**：通过重复地比较相邻两个元素并交换它们的位置，使较大的元素逐渐"冒泡"到数组的末尾。
- **时间复杂度**：O(n²)，无论输入如何，最坏、最好和平均情况都是O(n²)。
- **空间复杂度**：O(1)，只需要常数级别的额外空间。
- **稳定性**：稳定排序。
- **适用场景**：小规模数据或几乎已排序的数据，实际应用中较少使用。

## 2. 选择排序（Selection Sort）
- **算法思路**：每次从未排序部分选出最小（或最大）的元素，放到已排序部分的末尾。
- **时间复杂度**：O(n²)，无论输入如何都是O(n²)。
- **空间复杂度**：O(1)。
- **稳定性**：不稳定排序（例如，交换相同值的元素可能会改变它们的相对顺序）。
- **适用场景**：小规模数据，对稳定性要求不高的情况。

## 3. 插入排序（Insertion Sort）
- **算法思路**：将数组分为已排序和未排序两部分，依次将未排序部分的元素插入到已排序部分的适当位置。
- **时间复杂度**：
  - 最好情况：O(n)（已排序数据）
  - 最坏情况：O(n²)（逆序数据）
  - 平均情况：O(n²)
- **空间复杂度**：O(1)
- **稳定性**：稳定排序
- **适用场景**：小规模数据、几乎已排序的数据，在实际应用中比冒泡排序和选择排序更高效。

## 4. 希尔排序（Shell Sort）
- **算法思路**：插入排序的改进版，通过比较相距一定间隔的元素，逐步缩小间隔直至为1，完成最终排序。
- **时间复杂度**：取决于间隔序列，一般在O(n^(1.3))到O(n²)之间。
- **空间复杂度**：O(1)
- **稳定性**：不稳定排序
- **适用场景**：中等规模的数据，比普通插入排序效率高。

## 5. 归并排序（Merge Sort）
- **算法思路**：采用分治法，将数组分成两半，分别排序后再合并两个有序数组。
- **时间复杂度**：O(n log n)，无论输入如何都是O(n log n)。
- **空间复杂度**：O(n)，需要额外的数组空间来存储合并结果。
- **稳定性**：稳定排序
- **适用场景**：大规模数据，尤其是对稳定性有要求的场景。

## 6. 快速排序（Quick Sort）
- **算法思路**：选择一个"基准"元素，将数组分为两部分，小于基准的元素放在左边，大于基准的元素放在右边，然后递归地对这两部分进行快速排序。
- **时间复杂度**：
  - 最好情况：O(n log n)（基准选择得当）
  - 最坏情况：O(n²)（已排序或接近排序的数据，基准选择不当）
  - 平均情况：O(n log n)
- **空间复杂度**：O(log n)，递归调用栈的开销。
- **稳定性**：不稳定排序
- **适用场景**：大多数情况下的首选排序算法，速度快，适用于大规模数据。

## 7. 堆排序（Heap Sort）
- **算法思路**：利用堆这种数据结构进行排序，先构建最大堆（或最小堆），然后反复取出堆顶元素并调整堆结构。
- **时间复杂度**：O(n log n)，无论输入如何都是O(n log n)。
- **空间复杂度**：O(1)
- **稳定性**：不稳定排序
- **适用场景**：需要O(1)额外空间的排序场景，以及需要保证最坏情况下仍有较好性能的场景。

## 8. 计数排序（Counting Sort）
- **算法思路**：非比较排序算法，通过计算每个元素出现的次数，然后根据这些计数信息将元素放回原数组中。
- **时间复杂度**：O(n + k)，其中n是数组长度，k是数组中元素的最大值与最小值的差。
- **空间复杂度**：O(k)
- **稳定性**：稳定排序
- **适用场景**：有限范围内的整数排序，且k远小于n的情况。
//原理类似与哈希表,数在映射时就已经排号序,仅需输出即可

## 9. 桶排序（Bucket Sort）
- **算法思路**：将元素分配到有限数量的桶中，然后对每个桶内的元素进行排序（通常使用其他排序算法）。
- **时间复杂度**：
  - 最好情况：O(n + k)（均匀分布）
  - 最坏情况：O(n²)（所有元素都分到同一个桶）
  - 平均情况：O(n + k)
- **空间复杂度**：O(n + k)
- **稳定性**：取决于桶内使用的排序算法
- **适用场景**：均匀分布的数据，如浮点数排序。

## 10. 基数排序（Radix Sort）
- **算法思路**：非比较排序算法，从低位到高位（或从高位到低位）对数字进行排序，每一位使用计数排序等稳定排序算法。
- **时间复杂度**：O(n * k)，其中k是数字的位数。
- **空间复杂度**：O(n + k)
- **稳定性**：稳定排序
- **适用场景**：整数或字符串排序，且位数相对较少的情况。

## 排序算法对比总结

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
|---------|--------------|---------------|-----------|-------|
| 冒泡排序 | O(n²)        | O(n²)         | O(1)      | 稳定   |
| 选择排序 | O(n²)        | O(n²)         | O(1)      | 不稳定 |
| 插入排序 | O(n²)        | O(n²)         | O(1)      | 稳定   |
| 希尔排序 | O(n^(1.3))   | O(n²)         | O(1)      | 不稳定 |
| 归并排序 | O(n log n)   | O(n log n)    | O(n)      | 稳定   |
| 快速排序 | O(n log n)   | O(n²)         | O(log n)  | 不稳定 |
| 堆排序   | O(n log n)   | O(n log n)    | O(1)      | 不稳定 |
| 计数排序 | O(n + k)     | O(n + k)      | O(k)      | 稳定   |
| 桶排序   | O(n + k)     | O(n²)         | O(n + k)  | 稳定   |
| 基数排序 | O(n * k)     | O(n * k)      | O(n + k)  | 稳定   |

## 排序算法选择建议
1. 小规模数据：插入排序、选择排序
2. 中等规模数据：希尔排序
3. 大规模数据：快速排序、归并排序、堆排序
4. 要求稳定性：归并排序、插入排序、冒泡排序、计数排序、桶排序、基数排序
5. 空间限制严格：堆排序、希尔排序、选择排序、插入排序、冒泡排序
6. 特殊数据分布：考虑计数排序、桶排序、基数排序