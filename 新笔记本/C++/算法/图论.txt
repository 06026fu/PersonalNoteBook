算法
	拓扑排序
		目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。（仅针对有向无环图）
		构造拓扑序步骤：
		1.选择一个入度为0的点
		2.输出该点，从图中删除此点与其出边
		3.重复直到完成或死锁(有环存在找不到入度为0的点)

		Kahn算法
			开始
			S 装入度为0的点
			L=空
			than
			从S随便取个点放入L删除此点的边
			若某出边删除后他指向的点入度为0就放S里
			重复直到S空,检查图中是否有边(有边此图就有环)
			返回L即结果

		应用:
			判断有环否
			判断是否为链
			求AOE关键路劲
			求最短时间

			求字典序最大/小的拓扑排序
				Kahn队列换成大/小根堆
				O(边+点log点)
	最短路
		Dijkstra
		维护3个数组 存节点遍历状态 存目前最短路径 存使最短路径改变的点(前驱节点)
		Bellman-Ford
		
		
	最小生成树
		prim(加点)
		从一个节点开始 每次选择距离最小的节点 用新的边更新其他节点的距离(或称到某一节点的距离)
		和Dijkstra一样维护一个堆 把边塞进去 
		kruskal(加边)
		先以边权重建小根堆
		选取边时确保两点不在同一集合(两点间没有路径)//考虑并查集的unite
数据结构
	图
	E 边
	V 点
	子图
		G1={V1,{E1}}
		G2={V2,{E2}}
		if(V1包含v2 || E1包含E2){G2为G1的子图}
	构建
		邻接矩阵
			一个二维数组
			A[i][j]表示(i,j)是否相连
			空间复杂度O(V*V)
			查找复杂度O(1)
			遍历邻居O(V)
		邻接表
			用vector<节点 vector<节点>>
			节点 与其相连的节点
			空间小 快速遍历邻居 查找非常数时间
	
	遍历
		DFS
		本质上就是深度搜索
		return 会自行回到拐弯处 然后for会搜索下一条路
		n:点m:边
		Θ(n+m)
			dfs(点ID){
				cout<<点ID;
				for(遍历邻居){
					if(邻居未被标记){
						标记邻居;
						dfs(邻居);
					}
				}
			}

	衍生
		树

			宽度:某层最多的节点数量
			深度(高度)//根深度=1
			节点的度:节点拥有的子树个数/分支个数
			树的度:各节点度取最大

			特性 (2叉)
				第K层最多2^(k-1)个节点
				深度k的树 最多有2^k - 1个节点
				n个节点的完全二叉树深度: log n +1

			构建
				指针
			
			查找树
				左子数 < 根 <右子树
				其余参考《数据结构与算法》
			
			哈夫曼树(赫夫曼树/最优二叉树)
				仅叶子有权值 
				权: ~=值
				树的路径长: 根到每个节点的路径和
				节点带权路径长: 
				树的带权路径长: 叶子带权路径长和

				构建
					贪心 使树的带权路径长最小，即权重越大的节点里根越近
					选出2个权值最下的节点构建树,根节点权值为左右之和
					根权值放回待构建集合
					重复到完成
				
				应用
					压缩

		稀疏图 边数远小于点数的平方
		稠密图 边数接近点数的平方
		有向图
			入度:指向该点的边数
			出度:该点指出的边数
				有向无环图
					AOV网
					顶点表示活动，边表示优先关系
					AOE网
					一个带权有向无环图,顶点表事件,边表消耗等
					有些活动课并行,最小消耗为最长活动路径长(并非最深?)
					最长活动路径也是关键路径
					递推求最早/迟发生时间:
						按拓扑顺序求,最早发生时间从前往后递推最迟反之
						最早
						time(i)=max{time(j)+j->i权值|j∈i所有前驱事件的集合}
						最迟
						time(i)=min{time(i)-i->j权值|j∈i所有后驱事件的集合}
		无向图
		度:该点的边数