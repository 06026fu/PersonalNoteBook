#include <string>
#include <iostream>

每个项目必须有main函数
每一句代码以”;“结尾
//后跟注释或用/*内容*/注释
空格=tab
创建可折叠区域： tap {}自动折叠(有时候不灵) 类 函数 循环 选择 /**/ // 折叠

	1. 命名规范：/*
		变量名：
			- 小写字母
			- 单词之间用下划线分隔
		函数名：
			- 首字母大写
			- 单词之间用驼峰命名法
		类名：
			- 首字母大写
			- 单词之间用驼峰命名法
		常量名：
			- 全部大写
			- 单词之间用下划线分隔*/
	2. 命名规则：/*
		- 变量名：
			- 只能包含字母、数字和下划线
			- 不能以数字开头
			- 不能与关键字冲突
		- 函数名：
			- 与变量名相同
		- 类名：
			- 与变量名相同
		- 常量名：
			- 与变量名相同*/
	3. 命名习惯：/*
			- 尽量使用有意义的名字
			- 避免使用单个字符
			- 避免使用通用名字
*/

=============================预编译=============================

----------#include----------

使用
#include <名>包含标准c++头文件
#include "自定义文件名"

----------#define----------

定义#define 名字 值//他将在编译时把名字替换为值

----------头文件保护--------

#ifndef ABC//此名必须全文件唯一
#define ABC//同上
内容
#endif
防止头文件被重复包含

/*工作原理：
	1. 当第一次包含头文件时：
 	  - #ifndef 检查宏是否未定义 → 条件成立
 	  - #define 定义该宏
 	  - 执行后续代码直到#endif
	2. 当重复包含时：
 	  - #ifndef 检查到宏已定义 → 条件不成立
 	  - 跳过后续代码直到#endif
注意:
	命名规范：
	宏名格式：<文件名大写>_H（例：MYHEADER_H）
	忘记写#endif 后续所有文件都会被跳过！*/
================================================================
==============================函数==============================
================================================================

定义：
	返回类型 函数名 (参数1,参数2){
	内容
	return 变量or常量;
	}
	例
		int add(int a,int b){
			return a+b;
		}

使用:
	在使用之前需要有原型:
	返回类型 函数名(参数类型1,) 例:int add(int a,int b);
	可以自己调用自己

----------函数重载----------
定义：在同一作用域内，允许存在多个同名函数，条件是它们的参数列表不同（参数类型、数量或顺序不同）//重载原型,不重载定义

规则：
	1. 名相同 2. 参数列表必须不同（类型/数量/顺序）3. 返回类型不同不能重载4. 带const的引用参数与普通引用参数构成重载5. 重载解析发生在编译时
	例：
		// 参数类型不同
		void print(int i) ;
		void print(double d) ;
		// 参数数量不同
		int sum(int a, int b);
		int sum(int a, int b, int c);
		// 参数顺序不同
		void show(int a, double b) ;
		void show(double a, int b) ;
		// 带const的重载
		void process(std::string& str) ;
		void process(const std::string& str);
/*注意事项：
	1. 避免产生歧义的重载：
  	 void func(int a, double b = 3.14);//默认参数在不给本参数的时候做默认值,顺序从左到右不能跳过
	   void func(int a);// 调用func(5)会产生歧义
	2. 类型转换可能影响重载解析：
  	 print(3.14f); // 优先匹配float版本（如果没有则匹配double）
	3. 函数模板与重载的优先级关系：
  	 普通函数>模板实例化
  	 模板函数>普通函数
  	 模板函数之间的匹配优先度：
  	1. 精确匹配
  	2. 类型转换
  	3. 标准转换
  	4. 类类型转换
 	5. 数组/函数到指针
 	6. 可变参数模板
 	7. 函数指针
	8. 模板特化版本优先级高于通用版本*/
/*应用场景：
	1. 相同操作针对不同数据类型
	2. 简化接口（如构造函数重载）
	3. 处理不同参数组合*/

----------函数模板----------
定义：
	template <typename T> // 或 class T
	返回类型 函数名(参数列表) {
		// 函数体
	}
	例：
		template <class T>
		T max(T a, T b) {
   		 return (a > b) ? a : b;
		}
使用：
	函数名<类型>(参数1,参数2)
===================================================================
==============================数据类型==============================
===================================================================

-----------内置变量------------

创建:
	类型 名字;
	类型 名字=值;
	类型 名字={值1,值2,值3};
	类型 名字[]={值1,值2,值3};
	类型 名字[][]={{值1,值2,值3},{值1,值2,值3}}
	类型 名字={}

创建符号常量
	#define 名字 值
	const 类型 名字=值;/*只可在创建时初始化*/

 整数:short,int,long int/*简:long*/,long long int /*简:long long*/

 浮点数:float,double,long double/*有效位+放大倍数*/

 字符:char/*基础*/,wchar_t/*宽字符*/,char16_t/*UTF-16*/,char32_t/*UTF-32需#include <cuchar>*/
 他们都以整数储存对应的码不同

 字符串:string//需#include <string>

 布尔:bool/*true,false*/

 数组:
 	一维:
 		int a[10];
 	多维:
 		int a[3][4][5][6];
	/*数组头=指向[0]的指针*/

-----------指针----------------

指针:
	类型* 名字;
	类型* 名字=new 类型;
	类型* 名字=new 类型[数组长度];/*指针数组*/
	指针名=地址;
	*指针名=值;
	指针名[下标]=值;
迭代器
/*一种广义指针 可以是任何具有指针作用的类型 (具体见 C:\Users\Administrator\Desktop\笔记\C++\发现\STL.cpp)
*/
-----------引用----------------

	类型& 名字=值;/*普通引用*/
	类型&& 名字=值;/*右值引用*/
	/*引用使用限制：
	1. 必须初始化且不能改变绑定对象
	2. 不能引用临时对象（右值引用除外）
	3. 不能直接引用数组（需使用特殊语法）
	4. 不能创建引用的引用
	5. 类成员引用不能使用默认构造函数
	引用可以作为函数参数,返回值
	引用不能是常量,引用,类(不能直接引用类本身,但可绑对象),结构(同类)*/
	例:
		// 数组引用（C++11起支持）
		int arr[5] = {1,2,3,4,5};
		int (&arrRef)[5] = arr;  // 正确绑定整个数组
		// 函数引用
		void print(int) {}
		void (&funcRef)(int) = print;  

-----------结构体和类--------------

结构体://与类类似,但默认成员是public,类默认成员是private
	struct 结构体名{
		内容
	};
	结构体名 名字={值1,值2,值3};
类:看下面
=================================================================
==============================运算符==============================
=================================================================
目：运算符操作数个数

算术运算符:
	+	-	*	/	%	++	--
	加 减   乘   除	取余 自增 自减
关系运算符:
	==	!=		>	<	>=		<=
	等于 不等于	大于 小于 大于等于 小于等于

逻辑运算符:
	&&	||	!
	与 或 非
	/* 详细说明：
	1. 逻辑与（&&）：两操作数都为true时返回true
	   true && true → true
	   true && false → false
	
	2. 逻辑或（||）：至少一个操作数为true时返回true
	   true || false → true
	   false || false → false
	
	3. 逻辑非（!）：反转操作数的逻辑状态
	   !true → false
	   !(a == b) → 等价于 a != b*/
	/*注意：
	1. 逻辑与和逻辑或是短路操作，即当第一个操作数已经确定结果时，不会再计算第二个操作数。
	2. (!)的优先级高于算术和关系运算符，(&&,||)低于赋值运算符。
	3. 逻辑运算符的操作数可以是任何类型的表达式，包括布尔值、整数、浮点数等。
	4. 结果是布尔值（true或false）。
	5. 优先级低于算术和关系运算符，但高于赋值运算符。
	6. 结合性是从左到右。
	7. 可以嵌套使用。
	8. 的结果可以用于条件语句（if、while等）和逻辑表达式。
	9.的结果可以用于赋值语句,逻辑表达式中。
	*/

	//位逻辑运算优先级全部高于逻辑运算
	位运算符:
	&	|	^	~	<<	>>
	与 或 异或 取反 左移 右移
	
	&	仅当两个对应位都为1时为1
	|	有一个为1时为1
	^	两个位不同时为1
	~	1->0  0->1//单目运算
	num<<i	将num的2进制表示向左移i位

赋值运算符:
	=	+=	-=	*=	/=	%=	&=	|=	^=	<<=	>>=

其他运算符:
	&	*	sizeof	new		delete	->		->*			, 		.		 ? :
	地址 取值 大小	 分配内存 释放内存 指向成员 指向成员指针 分隔符 成员访问 条件运算符

类型转换运算符:
	static_cast<类型名>(变量);
	dynamic_cast<类型名>(变量);
	const_cast<类型名>(变量);
	类型名(变量);	类型名(常量);	类型名(表达式);	类型名(值);/*普通强制类型转换*/
===================================================================
==============================控制结构==============================
===================================================================

判断:
	if(条件){
	内容
	}
	else if(条件){
	内容
	}
	else{
	内容
	}
	switch (表达式)
	{
	case 值1:
		内容//没有break会继续执行下一个case
	case 值2:
		内容
		break;
	default://以上值都不符合时跳到这里
		内容
		break;
	}
循环:
	while(条件){
	内容
	}
	for(初始化;条件;更新){
	内容
	}
	do while (condition) {
		// 循环体
	} while (condition);
	/*do while 至少执行一次*/
	/*初始化可以定义变量
	更新可以是表达式
	条件可以是表达式,常量,变量*/
	switch (表达式) {//表达式必须是整数或字符类型
    case 表达式1:
        // 代码块1
        break;
    case 表达式2:
        // 代码块2
        break;
    default:
        // 默认代码块 若值全不匹配跳到这里
}
===================================================================
==========================内存模型和名称空间=========================
===================================================================
----------名称空间----------
	定义：	
	namespace 空间名{
		变量/函数/类/模板等定义
	
	作用：/*
	1. 避免命名冲突
	2. 组织大型项目代码
	3. 封装库实现细节*/
	
	使用场景：/*
	- 不同库的同名函数/类
	- 模块化开发时隔离代码
	- 防止与标准库名称冲突*/
	
	使用方法：/*
	1. 完全限定名：
	  空间名::成员名
	  例：std::cout
	
	2. using声明：
	  using 空间名::成员名;
	  例：using std::cout;
	
	3. using指令：
	  using namespace 空间名;
	  例：using namespace std;*/
	
	嵌套命名空间：
	namespace Outer {
		namespace Inner {
			void func();
		}
	}
	// C++17新语法
	namespace Outer::Inner {
		void func();
	}
	
	别名：
	namespace 别名 = 原命名空间; 例：namespace fs = std::filesystem;
	
	匿名命名空间：
	namespace {
		// 仅在当前文件可见
		int internalVar; 
	}
	
	全局命名空间：
	::全局函数(); // 访问全局作用域
	
	示例：
	// 定义命名空间
	namespace MyLib {
		void print() {
			std::cout << "MyLib print\n";
		}
	}
	
	int main() {
		// 三种调用方式
		MyLib::print();       // 直接调用
		using MyLib::print;   // using声明
		print();              
		using namespace MyLib;// using指令
		print();
	}
	}	
	注意事项：/*
	1. 避免在头文件中使用using指令
	2. 命名空间可以分散在多个文件
	3. 全局变量需用::访问
	4. 名称查找遵循最近匹配原则
	5. ADL（参数依赖查找）规则
	6. 可嵌套命名空间*/
	
----------内存模型----------

	栈：/*
		局部变量
		函数参数
		函数返回值
		函数调用*/
	堆：/*
		new分配的内存*/
	静态存储区：/*
		全局变量
		静态变量*/
	常量存储区：/*
		const变量
		字符串常量*/
	代码区：/*
		程序代码
		只读数据*/
	寄存器：/*
		CPU内部
		存储速度最快
		使用时需声明
		存储的数据不能超过寄存器的大小*/

-----------作用域-----------

	全局作用域：
		整个程序
	局部作用域：
		函数内部
	块作用域：
		{}
	命名空间作用域：
		namespace
	类作用域：
		class
	函数原型作用域：
		函数声明
	文件作用域：
		文件内部
	注意：
		作用域链：
			从内向外查找
		同名变量：
			局部变量优先
			嵌套作用域中同名变量屏蔽外层作用域
		生命周期：/*
			静态变量：
				整个程序
			局部变量：
				函数调用
			动态分配：
				new
			常量：
				程序运行*/
		访问权限：/*
			全局变量：
				整个程序
			局部变量：
				函数内部
			静态变量：
				文件内部
			常量：
				程序运行*/
		生命周期和访问权限：
======================================================
==========================类==========================
======================================================
//新建类型：
	class MYclass
	{
		//友元；
		friend MYclass2;
		friend void operator<<(std::ostream& os, const MYclass& value);//有了他后就可以用cout<<MYclass;
		private:
			//私有成员，可以是任意数据,只能通过公有方法（函数）访问
			int a;
			int* b;
			int c=1;//c++11允许类定义内初始化	
			/*数据成员*/
			int f1 ()const{}//就地定义的函数视为内联函数


		public:
			//公有成员,一般是方法（函数）也称接口
			MYclass();//默认构造函数，不接受任何值或所有参数都有默认值
			MYclass(int x);//转换构造函数，接受一个参数
			MYclass(const MYclass&);/*复制构造函数
									每当程序生成对象副本时都会调用此构造函数，
									因为c++使用按值传递*/
			//构造函数(创建对象)
			//语句创建对象就使用构造，修改已有对象的值用符值符
			~MYclass();//构析函数,用于删除对象
			
			void operator+(){};//重载运算符
			/*要求至少有一个操作数是用户定义的类型
			只要函数特征标不同就可多次重载
			不能重载内置类型的运算符 改变运算符的优先级 运算符的操作数个数 创建新的运算符
				不能重载的运算符：
					. 成员访问运算符
					.* 成员指针访问运算符
					:: 作用域解析运算符
			赋值运算符必须处理自赋值情况
			*/
			
};
/*注意事项：
	类作用域：
		类的所有成员都在类的作用域中外部不可见
		成员函数可以直接访问类的其他成员
		
	this指针 指向当前对象
	包含指针成员时必须手动实现深拷贝
*/
//定义类方法（函数）
	MYclass::f1(){};
	MYclass::MYclass():a(0),b(nullptr){};/*列表初始化
	const成员 引用成员 继类的基类部分 必须使用初始化列表
	*/
	void operator<<(std::ostream& os, const MYclass& value){};
	MYclass::MYclass(int x){};
	MYclass::MYclass(const MYclass&){};
	MYclass::~MYclass(){};

使用：

//类可嵌套
----------动态内存----------

----------友元----------

//友元函数
friend void f1();
//友元类
friend class MYclass;
//友元成员函数
friend void MYclass::f1();
//友元成员函数
friend void MYclass::f2();
/*	友元函数：
		可以访问类的私有成员
		不能继承
	友元类：
		可以访问类的私有成员
		不能继承
	友元成员函数：
		可以访问类的私有成员
		不能继承*/
/*注意事项：
	友元不能传递 不能继承 是单向的 不能被继承 不可从外强加友情*/

----------继承----------

	继承方式：{
	/*公有继承：
		基类的公有成员和保护成员在派生类中保持原有访问属性
		基类的私有成员在派生类中不可访问*/
	/*私有继承：
		基类的公有成员和保护成员在派生类中变为私有成员
		基类的私有成员在派生类中不可访问*/
	/*保护继承：
		基类的公有成员和保护成员在派生类中变为保护成员
		基类的私有成员在派生类中不可访问
		派生类可访问基类保护成员，外界不行*/
	/*注意事项：
		派生类可以访问基类的公有和保护成员
		派生类不能访问基类的私有成员*/
	多重继承：//MI
	class MYclass1:public MYclass
	//    继类名  继承方式 基类名
	//继承方式：
	{
		private:
			//私有成员
		public:
			//公有成员
	};
	class A:virtual public B{};
	class C:virtual public A{};
	class D:public B,public C{};
	//虚基类解决重复继承 B,C共有部分被共用了
	//在基类是虚时信息无法间接传给基类（中间隔了个基类）	直接传给基类就行	非多重继承不能用
	D::D()
	:B(),C(),A() {};
	//使用::局限函数作用域以防二义性
	void D::show() {
		B::show();//调用基类方法
		C::show();
	}//这会使A::show()被调用两次
	//解决方法: 模块化处理（拆分工作）
	//保护访问解决接口过多
	}
	
	/*注意事项：
		派生类不可直接访问基类的私有成员
		基类指针可派生类对象（反之不可）
		创建派生类对象是必先创建基类部分
		派生对象可使用基类方法（非私有）
			标准技术是使用::访问
			若没有重定义则无需
		继承建立is-a关系（派生对象也是基类对象）
	*/
多态:
	//希望同一函数在不同类的行为不同
	class Base {
	public:
		virtual void show() { // 声明虚函数 需用virtual标识出来
			std::cout << "Base class\n";
		}
	};
	class Derived : public Base {
		public:
			void show() override { // 使用override明确重写
				std::cout << "Derived class\n";
			}
	};
	/*	virtual ：声明/引入新的虚函数 基类中为虚派生中自动为虚无需virtual（除非final了）
		override ：显式标记重写基类虚函数（C++11起）
		final ：禁止后续派生类重写（C++11起）
	*/
	/*注意事项：
	非虚 指针调用根据指针类型选择方法
	虚 指针调用根据指向对象类型选择方法
	析构最好是虚的 以确保正确的删除顺序
		派生类的析构函数应调用基类的析构函数
		若使用new则必须定义显式析构函数
		若使用智能指针则无需定义
	友元不为虚（他不是成员）
	静态成员函数不为虚
	默认使用最新版本的虚（位于派生链最后版本，也就是对象所属的类的版本，应为重定义覆盖了之前的）
	*/
	纯虚函数：//包含纯虚函数的类称为抽象类 无法创建对象
		virtual void f() = 0;
		/*	没有实现的虚函数 类中不可定义
			抽象类不能实例化
			派生类必须实现纯虚函数
			派生类可以实现其他虚函数
			抽象基类(ABC)使得从他派生的所有组件至少支持ABC的功能（一种接口约定）
			未实现所有纯虚函数的派生类仍为抽象类*/

=====================================================================
================================模板=================================
=====================================================================
----------函数模板----------

template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}
----------类模板----------

template <typename T, int N>
class Box {
private:
    T items[N];
public:
    void addItem(int index, const T& item) {
        items[index] = item;
    }
    T getItem(int index) const {
        return items[index];
    }
};

template <typename T,int N>
//typename 标识类型参数 int(具体类型)表达式参数可是式整、枚举、指针、引用 实例化时必须是常量表达式

//可递归使用模板 可包含多个类型参数、表达式参数
//隐式实例化（生成，在需要对象之前不生成）	显式实例化（即使没有对象也生成）	显示具体化（特定类型的定义）
----------具体化----------

	//函数
	template <>
	返回类型 函数名<具体类型>(参数列表)
	//类
	//从左到右填模板参数 可余下不填
	//不能特化函数模板的默认参数
	template <>
	class <class T1,class T2> class pair{};//源模板
	class <class T1>class pair<T1,int>//半特化模板
	//有多个模板待选时 选择最匹配的

	//若在模板例套模板则定义内模板时
		template <typename T> 
			template <typename U> class A{};
	//模板默认参数
	template <typename T,typename U=int> class A{};

----------模板友元----------

	//非模板友元
	friend void f(){};
	friend class A{};
	friend void f2(A<T>){};//为友元类提供模板参数
	//模板友元
		//约束模板友元 使类的具体化获得一个与友元匹配的具体化
		template <typename T> void f3{};//在类定义前声明模板函数
		friend void f3<TT>(A<TT>&type);//类内将类模板的类型参数传给函数模板
		//非约束模板友元
		template <typename T> void f4{};//类内声明模板 每个函数具体化都是每个类具体化的友元 友元模板类型参数与类类型参数可以不同

----------模板别名----------

	//跟typedef类似
	using 别名=模板名<参数>;
	using 别名=int;

----------向前声明----------

class A;
void f(A a);//向前声明
class A{//实际定义
	void f(A a);//实际调用
};
/*解决循环依赖*/
/*限制:
	不能定义对象
	只能声明指针/引用类型成员
	不能访问类的成员（需看到完整定义）*/
典例
	class Teacher;
	class Student {
		friend class Teacher; // 友元前向声明
	};
=====================================================================
==============================关键字大全==============================
=====================================================================

	alignas	alignof asm			
	/*指定变量或类型的对齐要求 alignas(16) int arr[4];强制16字节对齐 
		获取类型的对齐要求 alignof(double) 返回double类型的对齐字节数 
		嵌入汇编代码 asm("mov eax, 5");*/
	auto
	/*自动类型推导*/
	break case catch continue false true for goto if do else return while void switch
	/*	break 跳出循环
		case  用于switch语句
		catch	捕获异常
		continue继续下一轮循环
		false	布尔值
		ture	布尔值
		for循环
		跳转
		if判断
		do-while循环
		else	用于if语句
		函数返回
		while循环
		类型参数 表无特定类型*/
	const constexpr const_cast	/*常量
		常量表达式
		常量指针转换*/
	default/*默认值*/
	delete new nullptr/*释放指针
		分配内存
		空指针*/
	explicit friend virtual operator+ private: protected: public: mutable/*禁止隐式类型转换
		友元
		虚类/函数
		符号
		私有
		保护
		公共
		允许const成员函数修改成员
		*/
	export extern static inline/*导出
		外部连接性
			告诉编译器该变量在其他文件中定义 避免二义性 多文件项目中共享全局变量时使用
			函数默认拥有
		表内部连接（文件内可见）
		内联函数*/
	 /*	*/
	namespace using typedef/*命名空间 创建名称空间
		用于名称相关 类型别名、名称空间别名、导入名称
		类型别名*/
	noexcept/*声明函数不抛出异常*/
	sizeof/**/
	static static_assert static_cast/**/
	template this thread_local/**/
	throw try catch/*发出异常
		尝试（与{}搭配{}中语句发出异常程序返回到try后面catch块）
		捕获异常
	*/
	typeid/*后跟()判断()中值的类型 需要typeinfo头文件*/
	typename/*用于模板 指示类型参数*/
	volatile /*声明该变量可能被意外修改 禁用编译器优化(删除语句等) 确保每次访问都直接问内存（用于硬件寄存器访问 多线程共享变量 信号处理程序修改的变量）
	*/
	/*
	register	C++17弃用，编译器自动优化
	export		原用于模板分离编译（C++11弃用）
	*/
	signed unsigned/*声明变量为有符号版
		无符号版*/
	class enum struct/*类定义、声明
		枚举 enum class Day { Mon, Tue, Wed };强制类型枚举 传统枚举会污染外层作用域 强类型枚举限定在枚举名作用域内
		结构体
		*/
	union/*共享内存空间的不同类型成员- 节省内存（尺寸等于最大成员的大小） 同一时间只能存储一个成员的值
	*/
	模板与概念（C++20新增）
	concept requires // 概念约束
	模块相关（C++20新增）
	module import // 模块系统
	协程相关（C++20新增）
	co_await co_return co_yield
	特性测试
	__has_cpp_attribute // 预定义宏（非关键字但重要）
	保留字（编译器特定）
	__int128	__m128	__m256 
/*=== 版本标注 ===
■ C++11新增：alignas, alignof, char16_t, char32_t, constexpr, 
           decltype, noexcept, nullptr, static_assert, thread_local
■ C++20新增：concept, requires

=== 使用注意 ===
1. mutable只能修饰类的非静态成员变量
2. friend可修饰友元函数/类
3. export保留用于模板分离（实际少用）
4. virtual只能用于类成员函数声明
5. using 的多用途：
   - 命名空间别名
   - 类型别名（替代typedef）
   - 继承构造函数*/
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
//本文档辅助相关无阅读价值
class MYclass2{};


